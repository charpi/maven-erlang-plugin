package eu.lindenbaum.maven.util;

import java.util.ArrayList;
import java.util.Collection;

import com.ericsson.otp.erlang.OtpErlangList;
import com.ericsson.otp.erlang.OtpErlangObject;

/**
 * Containing utilities related to collections.
 * 
 * @author Tobias Schlager <tobias.schlager@lindenbaum.eu>
 * @author Timo Koepke <timo.koepke@lindenbaum.eu>
 * @since 2.1.0
 */
public final class CollectionUtils {
  /**
   * Function that returns a value of type B for an argument of type A.
   */
  public static interface MapFunction<A, B> {
    public B apply(A a);
  }

  /**
   * Function that returns a value of type B for an argument of type A and an
   * accumulator argument of type B.
   */
  public static interface FoldFunction<A, B> {
    public B apply(A a, B acc);
  }

  /**
   * Maps a collection with elements of type A to a collection of type B, where
   * the resulting elements are generated by applying the function f to each
   * element of the given collection. The input collection is not modified.
   * 
   * @param f the function for generating elements
   * @param as the original collection
   * @return the generated collection
   */
  public static <A, B> Collection<B> map(MapFunction<A, B> f, Collection<A> as) {
    Collection<B> bs = new ArrayList<B>();
    for (A a : as) {
      bs.add(f.apply(a));
    }
    return bs;
  }

  /**
   * Maps an {@link OtpErlangList} with elements of type {@link OtpErlangObject}
   * to a collection of type B, where the resulting elements are generated by
   * applying the function f to each element of the given collection.
   * 
   * @param f the function for generating elements
   * @param as the original list
   * @return the generated collection
   */
  public static <B> Collection<B> map(MapFunction<OtpErlangObject, B> f, OtpErlangList as) {
    Collection<B> bs = new ArrayList<B>();
    for (OtpErlangObject a : as.elements()) {
      bs.add(f.apply(a));
    }
    return bs;
  }

  /**
   * Removes elements from a collection which do not satisfy a given predicate.
   * The input collection is not modified.
   * 
   * @param p the predicate for testing elements
   * @param as the original collection
   * @return the filtered collection
   */
  public static <A> Collection<A> filter(Predicate<A> p, Collection<A> as) {
    Collection<A> bs = new ArrayList<A>();
    for (A a : as) {
      if (p.pred(a)) {
        bs.add(a);
      }
    }
    return bs;
  }

  /**
   * Applies a function f on each element of a collection passing through an
   * accumulator argument which is an argument for the call to f.
   * 
   * @param f the function generating results
   * @param initial the start argument for the fold operation
   * @param as the collection to iterate
   * @return the accumulator as returned by the last call to f
   */
  public static <A, B> B foldl(FoldFunction<A, B> f, B initial, Collection<A> as) {
    B acc = initial;
    for (A a : as) {
      acc = f.apply(a, acc);
    }
    return acc;
  }
}
